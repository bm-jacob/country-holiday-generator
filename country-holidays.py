#!/usr/bin/env python3
"""
This script generates national holiday dates for countries. It will produce alarms
- from current date 
- till  the end of next calendar year

Usage:
1. enable all needed countries in `holiday_enabled_countries.csv`
2. run script. If no `-o` or `--output` file provided the filename will be autogenerated


Requirements:
    - Python 3.6+
    - holidays module (see requirements.txt)
"""

import argparse
import csv
import datetime
from dataclasses import dataclass
from typing import Callable, List, Tuple, Type

import holidays
from holidays import HolidayBase


@dataclass
class CountryConfigDto:
    """Dto to validate the country,flag file

    Raises:
        ValueError: on failed validation

    """

    name: str
    code: str
    enabled: str

    def __post_init__(self):
        """Do a sanity check if fields are right type and not empty"""
        try:
            for field in (self.name, self.code, self.enabled):
                self._validate_is_non_empty_string(field)

            self._validate_if_true_or_false(self.enabled)

        except ValueError as e:
            raise ValueError(
                f"one or more empty values: name[{self.name}] code[{self.code}] enabled[{self.enabled}]. {e}"
            ) from e

    def _validate_is_non_empty_string(self, test_string) -> None:
        if not isinstance(test_string, str) or not test_string:
            raise ValueError("string must be a non-empty string")

    def _validate_if_true_or_false(self, test_string) -> None:
        if not isinstance(test_string, str) or not test_string in ("TRUE", "FALSE"):
            raise ValueError("enabled must be TRUE or FALSE (capitlized)")


def process_csv_line(line: dict) -> None:
    """
    Process a single line from the CSV file.

    :param line: A dictionary representing a single row from the CSV file.
    """

    return CountryConfigDto(**line)


def read_csv_and_process(file_path: str, process_function: Callable[[dict], None]) -> None:
    """
    Read a CSV file line by line, ignoring the header, and execute a function on each line.

    :param file_path: Path to the CSV file.
    :param process_function: A function to execute for each line. It takes a dictionary as an argument.
    """

    enabled_countries_list = []

    with open(file_path, mode="r", newline="", encoding="utf-8") as csv_file:
        reader = csv.DictReader(csv_file)

        for line in reader:
            _ = process_function(line)
            if _.enabled == "TRUE":
                enabled_countries_list.append(_)

    return enabled_countries_list


def generate_list_of_holidays(
    country_holidays: Type[HolidayBase], start_date: datetime.date = datetime.date.today()
) -> List[Tuple[str, str]]:

    holiday_list = [
        (country_holidays.country, str(holiday_date))
        for holiday_date, holiday_name in country_holidays.items()
        if start_date <= holiday_date
    ]

    return holiday_list


def get_holiday_dates(country_code: str, number_of_years: int = 2):

    start_year = datetime.date.today().year

    return generate_list_of_holidays(
        holidays.country_holidays(country_code, expand=True, years=range(start_year, start_year + number_of_years)),
    )


def save_to_csv(list_to_save: List[Tuple[str, str]], file_path: str) -> None:
    """
    Save a list of tuples to a CSV file with header and without quotes.

    :param data: List of tuples to save. Each tuple contains a date and a string.
    :param file_path: Path to the CSV file to save the data.
    """
    with open(file_path, mode="w", newline="", encoding="utf-8") as file:
        writer = csv.writer(file, quoting=csv.QUOTE_NONE)
        writer.writerow(["COUNTRY", "DATE"])
        for row in list_to_save:
            writer.writerow(row)


def main():
    """Generate holidays days"""

    parser = argparse.ArgumentParser(description="Generate national holiday dates in CSV format")
    parser.add_argument("-o", "--output", help="Output file name")
    args = parser.parse_args()

    country_config_filepath = "holidays_enabled_countries.csv"
    enabled_countries_list = read_csv_and_process(country_config_filepath, process_csv_line)
    processed_country_holiday_list = []

    # TODO! Decude on :param observed
    # Whether to include the dates of when public holiday are observed (e.g. a holiday
    # falling on a Sunday being observed the following Monday). False may not work for all countries.

    for country in enabled_countries_list:
        print("Processing Country: ", country.name)
        processed_country_holiday_list.extend(
            get_holiday_dates(
                country.code,
            )
        )

    last_alarm_year = datetime.datetime.strptime(processed_country_holiday_list[-1][1], "%Y-%m-%d").year

    if args.output:
        generated_holidays_filepath = args.output
    else:
        parser.print_help()
        generated_holidays_filepath = f"country-holidays-from-{datetime.date.today()}-till-end-of-{last_alarm_year}.csv"

    save_to_csv(processed_country_holiday_list, generated_holidays_filepath)

    print("\nSaved dates for country holidays to: ", generated_holidays_filepath)


if __name__ == "__main__":
    main()
